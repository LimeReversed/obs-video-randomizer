import inspectimport obspython as obsimport osfrom Helpers import file_helper# Create static method like in Source for current scene, it's a source so... Maybe I could have a class# "Data" and put SourceSettings there? So then I always know what I'm getting back.class Resource(object):    def __init__(self, creator, releaser, creator_argument=None):        self.create = creator        self.creator_argument = creator_argument        self.release = releaser    def __enter__(self):        # If None then no argument?        self.resource = self.create(self.creator_argument)        return self.resource    def __exit__(self, *args):        if self.resource:            self.release(self.resource)class Source(Resource):    def __init__(self, name_of_source):        super().__init__(obs.obs_get_source_by_name, obs.obs_source_release, name_of_source)    @staticmethod    def get_current_scene():        return Resource(obs.obs_frontend_get_current_scene, obs.obs_source_release)    def get_source_name(self):        return obs.obs_source_get_name(self.resource)# Jag kan skapa source och Data på många olika sätt... så... lika bra bara använda Resource?# Ha statiska metoder som construct_source_from_name osv.# Ha dessa metoder i Resource? Eller kanske forfarande sortera dem i vad de returnerar?# Ha variabler med de olika creators istället? Eller i alla fall private variabler för releasers.# Nej, fördelen med statiska metoder är att jag kan tala om vad för creator argument som behövs.class Data(Resource):    def __init__(self, name_of_source):        super().__init__(obs.obs_get_source_by_name, obs.obs_data_release, name_of_source)class SourceSettings(Resource):    def __init__(self, source):        super().__init__(obs.obs_source_get_settings, obs.obs_data_release, source)def _inspect_object(obj):    for name, data in inspect.getmembers(obj):        if not name.startswith('__'):            print(f"{name}: {data}")def extract_paths_from_names(new_array):    file_list = []    for file_name in new_array:        if os.path.isdir(file_name):            extracted_video_files = file_helper.get_files(file_name)            file_list += extracted_video_files        elif os.path.isfile(file_name):            file_list += file_name    print("Extract path from names")    print(file_list)    return file_listdef extract_array_from_array_data(data_array):    file_list = []    if data_array:        count = obs.obs_data_array_count(data_array)        for i in range(count):            item = obs.obs_data_array_item(data_array, i)            if item:                path = obs.obs_data_get_string(item, "value")                file_list.append(path)                obs.obs_data_release(item)        obs.obs_data_array_release(data_array)    print("Extract array from data results")    print(file_list)    return file_listdef set_array(source_name, new_list):    with Source(source_name) as source:        if source:            with SourceSettings(source) as data:                if data:                    array = obs.obs_data_array_create()                    for list_item in new_list:                        item = obs.obs_data_create()                        obs.obs_data_set_string(item, "value", list_item)                        obs.obs_data_array_push_back(array, item)                        obs.obs_data_release(item)                    obs.obs_data_set_array(data, "used_videos", array)                    obs.obs_source_update(source, data)                    used_videos_array = obs.obs_data_get_array(data, "used_videos")                    obs.obs_data_array_release(array)                    obs.obs_data_array_release(used_videos_array)